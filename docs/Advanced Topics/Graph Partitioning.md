35、 图分区
---

当JanusGraph部署在多个存储后端实例的集群上时，图表将在这些计算机上进行分区。由于JanusGraph将图形存储在邻接列表表示中，因此将顶点分配给机器确定了分区。默认情况下，JanusGraph使用随机分区策略将顶点随机分配给计算机。随机分区非常有效，无需配置，并可实现平衡分区。目前不支持显式分区。
```
cluster.max-partitions = 32
id.placement = simple
```
配置选项max-partitions控制JanusGraph创建的虚拟分区数。此数字应大约是存储后端实例数的两倍。如果预计存储后端实例集群将增长，请在可预见的未来估计集群的大小，并将此数量作为基准。将此数字设置得过大会不必要地破坏群集，从而导致性能下降。此数字应大于JanusGraph图中最大预期节点数。它必须大于1且幂为2。

图形分区有两个方面可以单独控制：边缘切割和顶点切割。


### 35.1 边缘切割
在将顶点分配给分区时，人们努力优化分配，使得经常共同遍历的顶点托管在同一台机器上。假设顶点A分配给机器1，顶点B分配给机器2.顶点之间的边缘称为切边，因为它的端点托管在不同的机器上。遍历此边缘作为图形查询的一部分需要在机器之间进行通信，这会减慢查询处理速度。因此，希望减少频繁遍历边缘的边缘切割。反过来，这需要将频繁遍历的边缘的相邻顶点放置在同一分区中。

顶点通过指定的顶点id放置在分区中。分区本质上是顶点id的连续范围。要在特定分区中放置顶点，JanusGraph会从分区的顶点id范围中选择一个id。JanusGraph通过配置的放置策略控制顶点到分区的分配。默认情况下，在同一事务中创建的顶点将分配给同一分区。这种策略很容易推理，并且在同一事务中经常共同遍历顶点的情况下运行良好 - 通过优化加载策略到该效果，或者因为顶点自然地以这种方式添加到图形中。但是，策略是有限的，当在大型事务中加载数据时导致不平衡的分区，而不是许多用例的最佳策略。IDPlacementStrategy接口并通过ids.placement选项在配置中注册它。

实现时IDPlacementStrategy，请注意分区由整数id标识，范围从0到配置的虚拟分区数减1.对于我们的示例配置，有分区0,1,2,3，..31。分区ID与顶点ID不同。当JanusGraph服务器与存储后端位于同一主机上时，边缘切割更有意义。如果您必须在遍历的每一跳上对不同的主机进行网络呼叫，则边缘削减和自定义放置策略的好处可能会大大无效。

### 35.2 顶点切割
边切优化旨在减少交叉通信，从而改善查询执行，而顶点切割解决了由具有大量入射边的顶点引起的热点问题。虽然以顶点为中心的索引有效地解决了大度顶点的查询性能，但是需要顶点切割来解决非常大的图上的热点问题。

剪切顶点意味着在图中的每个分区上存储该顶点的邻接列表的子集。换句话说，顶点及其邻接列表被分区，从而有效地将该单个顶点上的负载分布在集群中的所有实例上并移除热点。

JanusGraph按标签切割顶点。顶点标签可以定义为分区，这意味着该标签的所有顶点将以上述方式在整个集群中进行分区。

```
mgmt = graph.openManagement()
mgmt.makeVertexLabel('user').make()
mgmt.makeVertexLabel('product').partition().make()
mgmt.commit()
```

在上面的示例中，product定义为分区顶点标签，user是普通标签。这种配置有利于数千种产品但数百万用户和用户与产品之间记录交易的情况。在这种情况下，产品顶点将具有非常高的程度，如果没有分区，流行的产品将变成热点。

### 35.3 图分区常见问题解答
#### 35.3.1 随机分区与显式分区
当图表很小或由少数存储实例容纳时，最好使用随机分区以简化。根据经验，当图形增长到数十亿个边缘的10s时，应该强烈考虑启用显式图形分区并配置合适的分区启发式算法。
